from datetime import datetime, timezone

import serial
import time
import re
import matplotlib.pyplot as plt
from supabase import create_client, Client

# --- Supabase setup ---
SUPABASE_URL = "https://tslcyteqrbeiwjifpdeb.supabase.co"
SUPABASE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InRzbGN5dGVxcmJlaXdqaWZwZGViIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjE2NTcwMzIsImV4cCI6MjA3NzIzMzAzMn0.VWqv2VkqJ7csDKn6G947T-J7Pf9jlHhGWo33B0eof2s"
supabase: Client = create_client(SUPABASE_URL, SUPABASE_KEY)

# --- Arduino setup ---
port = '/dev/cu.usbmodem14201'
baud = 9600
max_points = 50
x_window = 10

print("Connecting to Arduino...")
ser = serial.Serial(port, baud, timeout=1)
time.sleep(2)
print(f"Connected to {port}")

# --- Matplotlib setup ---
fig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(15, 4))
plt.ion()
plt.show()

# Data buffers
force_data, flex_data, move_data = [], [], []
force_time, flex_time, move_time = [], [], []

# PSI conversion
def fsr_to_psi(analog_value, r_fixed=10000, k=800000, area_in2=0.125, calibration_factor=5.0):
    if analog_value <= 0: return 0
    if analog_value >= 1023: analog_value = 1022.9

    r_fsr = r_fixed * (1023 - analog_value) / analog_value
    if r_fsr <= 0: return 0

    force_g = k / r_fsr
    psi = (force_g * 0.00220462) / area_in2
    psi *= calibration_factor
    return psi

# Plot lines
force_line, = ax1.plot([], [], label="Force Sensor", color='blue')
flex_line,  = ax2.plot([], [], label="Flex Sensor", color='green')
move_line,  = ax3.plot([], [], label="Movement Sensor", color='orange')

threshold_psi = 20
tolerance = 2
ax1.axhline(y=threshold_psi, color='red', linestyle='--', label=f"Threshold ({threshold_psi} PSI)")

# Graph appearance
for ax, title in zip([ax1, ax2, ax3],
                     ["Force Sensor Data", "Flex Sensor Data", "Movement Sensor Data"]):
    ax.set_xlim(0, x_window)
    ax.set_ylim(0, 1023)
    ax.set_xlabel("Time (s)")
    ax.set_ylabel("Analog Reading")
    ax.set_title(title)
    ax.legend()

ax1.set_ylabel("Force (PSI)")
ax1.set_ylim(0, 50)

# --- Real-time scoring ---
start_time = time.time()
time_on_threshold = 0.0
last_update_time = start_time

try:
    while True:
        if ser.in_waiting > 0:
            raw_line = ser.readline().decode('utf-8', errors='ignore').strip()
            print(raw_line)

            match = re.search(r'(\d+)', raw_line)
            if not match:
                continue

            raw_value = float(match.group(1))
            current_time = time.time() - start_time

            # -----------------------------
            # FORCE SENSOR PROCESSING
            # -----------------------------
            if "Force" in raw_line:
                psi_value = fsr_to_psi(raw_value)

                force_time.append(current_time)
                force_data.append(psi_value)

                if len(force_data) > max_points:
                    force_data = force_data[-max_points:]
                    force_time = force_time[-max_points:]

                # Scoring logic
                now = time.time()
                time_delta = now - last_update_time
                last_update_time = now

                if abs(psi_value - threshold_psi) <= tolerance:
                    time_on_threshold += time_delta

                duration = now - start_time
                percentage_on_line = (time_on_threshold / duration) * 100 if duration > 0 else 0

                # Save to Supabase
                data = {
                    "force": float(psi_value),
                    "score": float(percentage_on_line),
                    "timestamp": datetime.now(timezone.utc).isoformat()
                }

                try:
                    response = supabase.table("trainee_data").insert(data).execute()
                    print("Uploaded:", response)
                except Exception as e:
                    print(f"Supabase upload error: {e}")

                # Update plot
                force_line.set_xdata(force_time)
                force_line.set_ydata(force_data)
                ax1.relim()
                ax1.autoscale_view(True, True, True)

            # -----------------------------
            # FLEX SENSOR PROCESSING
            # -----------------------------
            elif "Flex" in raw_line:
                flex_time.append(current_time)
                flex_data.append(raw_value)

                if len(flex_data) > max_points:
                    flex_data = flex_data[-max_points:]
                    flex_time = flex_time[-max_points:]

                flex_line.set_xdata(flex_time)
                flex_line.set_ydata(flex_data)
                ax2.relim()
                ax2.autoscale_view(True, True, True)

            # -----------------------------
            # MOVEMENT SENSOR PROCESSING
            # -----------------------------
            elif "Movement" in raw_line:
                move_time.append(current_time)
                move_data.append(raw_value)

                if len(move_data) > max_points:
                    move_data = move_data[-max_points:]
                    move_time = move_time[-max_points:]

                move_line.set_xdata(move_time)
                move_line.set_ydata(move_data)
                ax3.relim()
                ax3.autoscale_view(True, True, True)

            # Shift x-windows
            for ax, t in zip([ax1, ax2, ax3], [force_time, flex_time, move_time]):
                if len(t) > 0:
                    ax.set_xlim(max(0, t[-1] - x_window), t[-1])

            plt.pause(0.05)

# -----------------------------
# CLEAN EXIT
# -----------------------------
except KeyboardInterrupt:
    duration = time.time() - start_time
    percentage_on_line = (time_on_threshold / duration) * 100 if duration > 0 else 0

    print("\n--- Session Ended ---")
    print(f"Duration: {duration:.2f} s")
    print(f"Time on threshold: {time_on_threshold:.2f} s")
    print(f"Score: {percentage_on_line:.1f}%")

    plt.ioff()
    plt.show()
    ser.close()
